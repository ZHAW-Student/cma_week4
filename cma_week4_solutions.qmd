---
title: "Exercise Week 4 solutions"
format: html
editor: visual
author: "Saskia Gianola"
message: false
---

## Packages

```{r}
library("readr")
library("dplyr")
library("sf")
library("ggplot2")
library("tidyverse")
library("here")
library("XML")
library("lubridate")
library("ggmap")
library("geosphere")
```

## Input

Load data and extract some movement of sabi. 

```{r}
wildschwein <- read_delim("wildschwein_BE_2056.csv", ",")
sabi <- wildschwein |>
  st_as_sf(coords = c("E", "N"), crs = 2056, remove = FALSE) |>
  filter(TierName == "Sabi", DatetimeUTC >= "2015-07-01", DatetimeUTC < "2015-07-03")
```

### Step a): Specify a temporal window

In the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):

pos[n-2] to pos[n]
pos[n-1] to pos[n]
pos[n] to pos[n+1]
pos[n] to pos[n+2]

### Step b): Measure the distance from every point to every other point within this temporal window

We can use the function distance_by_element from week 2 in combination with lead() and lag() to calculate the Euclidean distance. For example, to create the necessary offset of n-2, we use lag(x, 2). For each offset, we create one individual column.

```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}

sabi <- sabi |>
    mutate(
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  # distance to pos -30 minutes
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  # distance to pos -15 minutes
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), # distance to pos +15 mintues
        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  # distance to pos +30 minutes
    )
```
Now we want to calculate the mean distance of nMinus2, nMinus1, nPlus1, nPlus2 for each row. Since we want the mean value per Row, we have to explicitly specify this before mutate() with the function rowwise(). To remove this rowwise-grouping, we end the operation with ungroup().

Note that for the first two positions, we cannot calculate a stepMean since there is no Position n-2 for these positions. This is also true for the last to positions (lacking a position n+2).

```{r}
sabi <- sabi |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

sabi
```
### Step c): Remove “static points”

We can now determine if an animal is moving or not by specifying a threshold distance on stepMean. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.

```{r}
sabi <- sabi |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

sabi_filter <- sabi |>
    filter(!static)

sabi_filter |>
    ggplot(aes(E, N)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

# Task 1: Segmentation
Load and prepare data
```{r}
act1_parsed <- htmlTreeParse(file = "activities/11034695746.gpx", useInternalNodes = TRUE)
act1_parsed

# get coordinates
coords <- xpathSApply(doc = act1_parsed, path = "//trkpt", fun = xmlAttrs)

# get elevation
elevation <- xpathSApply(doc = act1_parsed, path = "//trkpt/ele", fun = xmlValue)

# get time
time <- xpathApply(doc = act1_parsed, path = "//trkpt/time", fun = xmlValue)


# built data frame
act1_df <- data.frame(
  lat = as.numeric(coords["lat", ]),
  lon = as.numeric(coords["lon", ]),
  ts_POSIXct = ymd_hms(time, tz = "UTC"),
  elevation = as.numeric(elevation)
)
act1_df

act1 <- act1_df |> 
  st_as_sf(coords = c("lat", "lon"), crs = 4326 , remove = FALSE)

```

Specify temporal window and measure distance in my data

```{r}
distance_by_element <- function(later, now) {
  as.numeric(
    st_distance(later, now, by_element = TRUE)
  )
}

act1 <- act1 |>
    mutate(
        nMinus2 = distance_by_element(lag(geometry, 2), geometry),  
        nMinus1 = distance_by_element(lag(geometry, 1), geometry),  
        nPlus1  = distance_by_element(geometry, lead(geometry, 1)), 
        nPlus2  = distance_by_element(geometry, lead(geometry, 2))  
    )

act1
```


# Task 2: Specify and apply threshold 
Calculate mean Step

```{r}
act1 <- act1 |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

act1
```
Explore mean step to define threashold

```{r}
hist(act1$stepMean)
boxplot(act1$stepMean)
summary(act1$stepMean)
```
The median is 2.94, so we take 2.9 as threashold

```{r}
act1 <- act1 |>
    mutate(static = stepMean < 2.9, na.rm = TRUE)
```


# Task 3 : Visualize segmented trajectories



```{r}

```

# Task 4: Segment-based analysis



```{r}

```

# Task 5: Similarity measures



```{r}

```

# Task 6: Calculate similarity



```{r}

```

